#!/usr/bin/env python3

"""
Plots image gradients from a given CSV file.

This can be used to verify data generated by the 'label_data.py' script.
"""

import gelsight_ros as gsr
import csv
from csv import writer
import cv2
import gelsight_ros as gsr
import math
import numpy as np
import os
import rospy
import matplotlib.pyplot as plt

def get_param_or_err(name: str):
    if not rospy.has_param(f"~{name}"):
        rospy.signal_shutdown(f"Required parameter missing: {name}")
    return rospy.get_param(f"~{name}")

if __name__ == "__main__":
    rospy.init_node("plot")

    # Retrieve path where dataset is stored
    input_path = get_param_or_err("input_path") 
    if input_path[-1] == "/":
        input_path = input_path[:len(input_path)-1]

    # Retrieve sensor specific parameters
    imgw = get_param_or_err("image_width")
    imgh = get_param_or_err("image_height")
    mpp = get_param_or_err("mpp")

    # Collect gradient data
    file_labels = {}
    with open(input_path, 'r') as f:
        reader = csv.reader(f)
        for row in reader:
            img_name, R, G, B, x, y, gx, gy = row
            if img_name == "img_name":
                continue

            if img_name not in file_labels:
                file_labels[img_name] = np.zeros((imgh, imgw, 3))

            R = float(R)
            G = float(G)
            B = float(B)
            gx = float(gx)
            gy = float(gy)
            norm = math.sqrt((gx*gx) + (gy*gy)) 

            if norm == 0.0:
                ux = 0.0
                uy = 0.0
            else:
                ux = gx / norm
                uy = gy / norm
            ux = gx
            uy = gy
            file_labels[img_name][int(y)        # Interpolate gradients over markers
        gx, gy = demark(frame, gx, gy), int(x)] = [ux, uy, R + G + B]

    # Collect first image from dataset
    img = list(file_labels.keys())[0]
    X = np.arange(imgw)
    Y = np.flip(np.arange(imgh))
    U = file_labels[img][:, :, 1]
    V = file_labels[img][:, :, 0]
    C = file_labels[img][:, :, 2]

    # Plot matplotlib quiver
    fig, ax = plt.subplots()
    ax.quiver(X, Y, U, V, C) #, scale=30, width=0.0005)
    plt.show()

    # Plot open3d pointcloud
    vis3d = gsr.gs3drecon.Visualize3D(imgw, imgh, '', mpp)
    boundary = np.zeros((imgh, imgw))
    dm = gsr.util.poisson_reconstruct(U, V, boundary)
    dm = np.reshape(dm, (imgh, imgw))
    rate = rospy.Rate(10)
    while not rospy.is_shutdown():
        vis3d.update(dm)
        rate.sleep()
